Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    CTECHAR
    CTESTRING
    DECREMENT
    DO
    ELSE
    FOR
    IF
    INCREMENT
    MAIN
    MOD
    OR
    PLUSEQUALS
    PROGRAM
    READ
    RETURN
    SUBSTRACTEQUALS
    THEN
    TO
    WHILE
    WRITE

Grammar

Rule 0     S' -> program
Rule 1     program -> vars
Rule 2     vars -> VAR vartipo
Rule 3     vartipo -> tipo COLON ids SEMICOLON vartipo
Rule 4     vartipo -> tipo COLON ids SEMICOLON
Rule 5     ids -> declaraid COMMA ids
Rule 6     ids -> declaraid
Rule 7     declaraid -> ID dimen_declara dimen_declara
Rule 8     declaraid -> ID dimen_declara
Rule 9     declaraid -> ID
Rule 10    dimen_declara -> LEFTSQRBRACKET CTEINT RIGHTSQRBRACKET
Rule 11    tipo -> INT
Rule 12    tipo -> FLOAT
Rule 13    tipo -> CHAR
Rule 14    funcvoid -> MODULE ID parametros SEMICOLON vars bloque
Rule 15    funcvoid -> MODULE ID parametros SEMICOLON bloque
Rule 16    funcreturn -> tipo MODULE ID parametros SEMICOLON vars bloque
Rule 17    funcreturn -> tipo MODULE ID parametros SEMICOLON bloque
Rule 18    funciones -> funcvoid funciones
Rule 19    funciones -> funcreturn funciones
Rule 20    funciones -> funcvoid
Rule 21    funciones -> funcreturn
Rule 22    parametros -> LEFTPARENTHESIS paramlist RIGHTPARENTHESIS
Rule 23    paramlist -> tipo declaraid COMMA paramlist
Rule 24    paramlist -> tipo declaraid
Rule 25    bloque -> LEFTBRACKET estatuto RIGHTBRACKET
Rule 26    bloque -> LEFTBRACKET RIGHTBRACKET
Rule 27    mas_estatutos -> estatuto mas_estatutos
Rule 28    mas_estatutos -> estatuto
Rule 29    estatuto -> asignacion
Rule 30    asignacion -> ID dimensiones EQUALS expresion SEMICOLON
Rule 31    asignacion -> ID EQUALS expresion SEMICOLON
Rule 32    expresion -> exp comparadores exp
Rule 33    expresion -> exp
Rule 34    comparadores -> COMPARISON
Rule 35    comparadores -> GREATERHANOREQUAL
Rule 36    comparadores -> LESSTHANOREQUAL
Rule 37    comparadores -> GREATERTHAN
Rule 38    comparadores -> LESSTHAN
Rule 39    comparadores -> DIFFERENT
Rule 40    exp -> termino opera_exp exp
Rule 41    exp -> termino
Rule 42    opera_exp -> PLUS
Rule 43    opera_exp -> MINUS
Rule 44    termino -> factor opera_term termino
Rule 45    termino -> factor
Rule 46    opera_term -> MULTIPLY
Rule 47    opera_term -> DIVIDE
Rule 48    factor -> LEFTPARENTHESIS expresion RIGHTPARENTHESIS
Rule 49    factor -> opera_exp valor_opt
Rule 50    factor -> valor_opt
Rule 51    dimensiones -> dimen_expre dimen_expre
Rule 52    dimensiones -> dimen_expre
Rule 53    dimen_expre -> LEFTSQRBRACKET expresion RIGHTSQRBRACKET
Rule 54    valor_opt -> ID dimensiones
Rule 55    valor_opt -> ID
Rule 56    valor_opt -> CTEINT
Rule 57    valor_opt -> CTEFLOAT

Terminals, with rules where they appear

AND                  : 
CHAR                 : 13
COLON                : 3 4
COMMA                : 5 23
COMPARISON           : 34
CTECHAR              : 
CTEFLOAT             : 57
CTEINT               : 10 56
CTESTRING            : 
DECREMENT            : 
DIFFERENT            : 39
DIVIDE               : 47
DO                   : 
ELSE                 : 
EQUALS               : 30 31
FLOAT                : 12
FOR                  : 
GREATERHANOREQUAL    : 35
GREATERTHAN          : 37
ID                   : 7 8 9 14 15 16 17 30 31 54 55
IF                   : 
INCREMENT            : 
INT                  : 11
LEFTBRACKET          : 25 26
LEFTPARENTHESIS      : 22 48
LEFTSQRBRACKET       : 10 53
LESSTHAN             : 38
LESSTHANOREQUAL      : 36
MAIN                 : 
MINUS                : 43
MOD                  : 
MODULE               : 14 15 16 17
MULTIPLY             : 46
OR                   : 
PLUS                 : 42
PLUSEQUALS           : 
PROGRAM              : 
READ                 : 
RETURN               : 
RIGHTBRACKET         : 25 26
RIGHTPARENTHESIS     : 22 48
RIGHTSQRBRACKET      : 10 53
SEMICOLON            : 3 4 14 15 16 17 30 31
SUBSTRACTEQUALS      : 
THEN                 : 
TO                   : 
VAR                  : 2
WHILE                : 
WRITE                : 
error                : 

Nonterminals, with rules where they appear

asignacion           : 29
bloque               : 14 15 16 17
comparadores         : 32
declaraid            : 5 6 23 24
dimen_declara        : 7 7 8
dimen_expre          : 51 51 52
dimensiones          : 30 54
estatuto             : 25 27 28
exp                  : 32 32 33 40
expresion            : 30 31 48 53
factor               : 44 45
funciones            : 18 19
funcreturn           : 19 21
funcvoid             : 18 20
ids                  : 3 4 5
mas_estatutos        : 27
opera_exp            : 40 49
opera_term           : 44
parametros           : 14 15 16 17
paramlist            : 22 23
program              : 0
termino              : 40 41 44
tipo                 : 3 4 16 17 23 24
valor_opt            : 49 50
vars                 : 1 14 16
vartipo              : 2 3

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . vars
    (2) vars -> . VAR vartipo

    VAR             shift and go to state 3

    program                        shift and go to state 1
    vars                           shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> vars .

    $end            reduce using rule 1 (program -> vars .)


state 3

    (2) vars -> VAR . vartipo
    (3) vartipo -> . tipo COLON ids SEMICOLON vartipo
    (4) vartipo -> . tipo COLON ids SEMICOLON
    (11) tipo -> . INT
    (12) tipo -> . FLOAT
    (13) tipo -> . CHAR

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8

    vartipo                        shift and go to state 4
    tipo                           shift and go to state 5

state 4

    (2) vars -> VAR vartipo .

    $end            reduce using rule 2 (vars -> VAR vartipo .)


state 5

    (3) vartipo -> tipo . COLON ids SEMICOLON vartipo
    (4) vartipo -> tipo . COLON ids SEMICOLON

    COLON           shift and go to state 9


state 6

    (11) tipo -> INT .

    COLON           reduce using rule 11 (tipo -> INT .)


state 7

    (12) tipo -> FLOAT .

    COLON           reduce using rule 12 (tipo -> FLOAT .)


state 8

    (13) tipo -> CHAR .

    COLON           reduce using rule 13 (tipo -> CHAR .)


state 9

    (3) vartipo -> tipo COLON . ids SEMICOLON vartipo
    (4) vartipo -> tipo COLON . ids SEMICOLON
    (5) ids -> . declaraid COMMA ids
    (6) ids -> . declaraid
    (7) declaraid -> . ID dimen_declara dimen_declara
    (8) declaraid -> . ID dimen_declara
    (9) declaraid -> . ID

    ID              shift and go to state 12

    ids                            shift and go to state 10
    declaraid                      shift and go to state 11

state 10

    (3) vartipo -> tipo COLON ids . SEMICOLON vartipo
    (4) vartipo -> tipo COLON ids . SEMICOLON

    SEMICOLON       shift and go to state 13


state 11

    (5) ids -> declaraid . COMMA ids
    (6) ids -> declaraid .

    COMMA           shift and go to state 14
    SEMICOLON       reduce using rule 6 (ids -> declaraid .)


state 12

    (7) declaraid -> ID . dimen_declara dimen_declara
    (8) declaraid -> ID . dimen_declara
    (9) declaraid -> ID .
    (10) dimen_declara -> . LEFTSQRBRACKET CTEINT RIGHTSQRBRACKET

    COMMA           reduce using rule 9 (declaraid -> ID .)
    SEMICOLON       reduce using rule 9 (declaraid -> ID .)
    LEFTSQRBRACKET  shift and go to state 16

    dimen_declara                  shift and go to state 15

state 13

    (3) vartipo -> tipo COLON ids SEMICOLON . vartipo
    (4) vartipo -> tipo COLON ids SEMICOLON .
    (3) vartipo -> . tipo COLON ids SEMICOLON vartipo
    (4) vartipo -> . tipo COLON ids SEMICOLON
    (11) tipo -> . INT
    (12) tipo -> . FLOAT
    (13) tipo -> . CHAR

    $end            reduce using rule 4 (vartipo -> tipo COLON ids SEMICOLON .)
    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8

    tipo                           shift and go to state 5
    vartipo                        shift and go to state 17

state 14

    (5) ids -> declaraid COMMA . ids
    (5) ids -> . declaraid COMMA ids
    (6) ids -> . declaraid
    (7) declaraid -> . ID dimen_declara dimen_declara
    (8) declaraid -> . ID dimen_declara
    (9) declaraid -> . ID

    ID              shift and go to state 12

    declaraid                      shift and go to state 11
    ids                            shift and go to state 18

state 15

    (7) declaraid -> ID dimen_declara . dimen_declara
    (8) declaraid -> ID dimen_declara .
    (10) dimen_declara -> . LEFTSQRBRACKET CTEINT RIGHTSQRBRACKET

    COMMA           reduce using rule 8 (declaraid -> ID dimen_declara .)
    SEMICOLON       reduce using rule 8 (declaraid -> ID dimen_declara .)
    LEFTSQRBRACKET  shift and go to state 16

    dimen_declara                  shift and go to state 19

state 16

    (10) dimen_declara -> LEFTSQRBRACKET . CTEINT RIGHTSQRBRACKET

    CTEINT          shift and go to state 20


state 17

    (3) vartipo -> tipo COLON ids SEMICOLON vartipo .

    $end            reduce using rule 3 (vartipo -> tipo COLON ids SEMICOLON vartipo .)


state 18

    (5) ids -> declaraid COMMA ids .

    SEMICOLON       reduce using rule 5 (ids -> declaraid COMMA ids .)


state 19

    (7) declaraid -> ID dimen_declara dimen_declara .

    COMMA           reduce using rule 7 (declaraid -> ID dimen_declara dimen_declara .)
    SEMICOLON       reduce using rule 7 (declaraid -> ID dimen_declara dimen_declara .)


state 20

    (10) dimen_declara -> LEFTSQRBRACKET CTEINT . RIGHTSQRBRACKET

    RIGHTSQRBRACKET shift and go to state 21


state 21

    (10) dimen_declara -> LEFTSQRBRACKET CTEINT RIGHTSQRBRACKET .

    LEFTSQRBRACKET  reduce using rule 10 (dimen_declara -> LEFTSQRBRACKET CTEINT RIGHTSQRBRACKET .)
    COMMA           reduce using rule 10 (dimen_declara -> LEFTSQRBRACKET CTEINT RIGHTSQRBRACKET .)
    SEMICOLON       reduce using rule 10 (dimen_declara -> LEFTSQRBRACKET CTEINT RIGHTSQRBRACKET .)

